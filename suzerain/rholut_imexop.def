// #include-time parameters available followed by a sample usage.
// Each of these are #undef-ed at the end of this template file
//
// #define FUNCNAME()  /* Function name, e.g. suzerain_rholut_imexop_packc    */
// #define PACKFUNC()  /* bsmbsm.h pack function, e.g. suzerain_bsmbsm_zpackc */

void
FUNCNAME()(
        const double phi,
        const double km,
        const double kn,
        const suzerain_rholut_imexop_scenario * const s,
        const suzerain_rholut_imexop_ref      * const r,
        const suzerain_rholut_imexop_refld    * const ld,
        const suzerain_bsplineop_workspace    * const w,
        const int rho,
        const int rhou,
        const int rhov,
        const int rhow,
        const int rhoe,
        complex_double * const buf,
        suzerain_bsmbsm * const A,
        complex_double * const papt)
{
    // Compute the BSMBSM structure and named max_kl, max_ku views of w->D.
    *A = suzerain_bsmbsm_construct(5, w->n, w->max_kl, w->max_ku);
    const double * const M  = w->D[0] - (w->max_ku - w->ku[0]);
    const double * const D1 = w->D[1] - (w->max_ku - w->ku[1]);
    const double * const D2 = w->D[2] - (w->max_ku - w->ku[1]);
    assert(w->nderiv >= 2); // Enough derivatives in workspace?
    assert(A->ld == w->ld); // Compatible storage?
    const size_t bufbytes = A->ld*A->n*sizeof(buf[0]);

    // We do not know the leading dimension associated with the definition of
    // PACKFUNC() so we must overwrite every possible submatrix within PAPT.
    // This is only suboptimal for the zero (rho, rhoe) submatrix.

    if (rho >= 0) { // Prepare density row
        memset(buf, 0, bufbytes);

        if (rhou >= 0) PACKFUNC()(A, rho,  rhou, 1.0, buf, papt);
        if (rhov >= 0) PACKFUNC()(A, rho,  rhov, 1.0, buf, papt);
        if (rhow >= 0) PACKFUNC()(A, rho,  rhow, 1.0, buf, papt);
        if (rhoe >= 0) PACKFUNC()(A, rho,  rhoe, 1.0, buf, papt);

        suzerain_blas_dcopy(A->ld*A->n, M, 1, (double *) buf, 2);
        PACKFUNC()(A, rho,  rho, 1.0, buf, papt);
    }

    if (rhou >= 0) { // Prepare streamwise momentum row
        memset(buf, 0, bufbytes);

        if (rho  >= 0) PACKFUNC()(A, rhou, rho,  1.0, buf, papt);
        if (rhov >= 0) PACKFUNC()(A, rhou, rhov, 1.0, buf, papt);
        if (rhow >= 0) PACKFUNC()(A, rhou, rhow, 1.0, buf, papt);
        if (rhoe >= 0) PACKFUNC()(A, rhou, rhoe, 1.0, buf, papt);

        suzerain_blas_dcopy(A->ld*A->n, M, 1, (double *) buf, 2);
        PACKFUNC()(A, rhou, rhou, 1.0, buf, papt);
    }

    if (rhov >= 0) { // Prepare wall-normal momentum row
        memset(buf, 0, bufbytes);

        if (rho  >= 0) PACKFUNC()(A, rhov, rho,  1.0, buf, papt);
        if (rhou >= 0) PACKFUNC()(A, rhov, rhou, 1.0, buf, papt);
        if (rhow >= 0) PACKFUNC()(A, rhov, rhow, 1.0, buf, papt);
        if (rhoe >= 0) PACKFUNC()(A, rhov, rhoe, 1.0, buf, papt);

        suzerain_blas_dcopy(A->ld*A->n, M, 1, (double *) buf, 2);
        PACKFUNC()(A, rhov, rhov, 1.0, buf, papt);
    }

    if (rhow >= 0) { // Prepare spanwise momentum row
        memset(buf, 0, bufbytes);

        if (rho  >= 0) PACKFUNC()(A, rhow, rho,  1.0, buf, papt);
        if (rhou >= 0) PACKFUNC()(A, rhow, rhou, 1.0, buf, papt);
        if (rhov >= 0) PACKFUNC()(A, rhow, rhov, 1.0, buf, papt);
        if (rhoe >= 0) PACKFUNC()(A, rhow, rhoe, 1.0, buf, papt);

        suzerain_blas_dcopy(A->ld*A->n, M, 1, (double *) buf, 2);
        PACKFUNC()(A, rhow, rhow, 1.0, buf, papt);
    }

    if (rhoe >= 0) { // Prepare total energy row
        memset(buf, 0, bufbytes);

        if (rho  >= 0) PACKFUNC()(A, rhoe, rho,  1.0, buf, papt);
        if (rhou >= 0) PACKFUNC()(A, rhoe, rhou, 1.0, buf, papt);
        if (rhov >= 0) PACKFUNC()(A, rhoe, rhov, 1.0, buf, papt);
        if (rhow >= 0) PACKFUNC()(A, rhoe, rhow, 1.0, buf, papt);

        suzerain_blas_dcopy(A->ld*A->n, M, 1, (double *) buf, 2);
        PACKFUNC()(A, rhoe, rhoe, 1.0, buf, papt);
    }
}

#undef FUNCNAME
#undef PACKFUNC
