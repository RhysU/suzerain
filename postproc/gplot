#!/bin/bash
#
# gplot: Use gnuplot to plot one or more files directly from the command line.
#
# Copyright (C) 2010-2014 Rhys Ulerich
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

# Fail on first error
set -e

# Create temporary files to hold gnuplot script
tmp1=`mktemp "${TMPDIR-/tmp}/tmp.XXXXXXXXXX"`
tmp2=`mktemp "${TMPDIR-/tmp}/tmp.XXXXXXXXXX"`
trap "rm -f $tmp1 $tmp2" EXIT

# Process (and then remove) command line options
# Build up any post-terminal processing in tmp2 for later use
autotitle=
title="`date +%r`: gplot $*"
terminal="set terminal ${GNUTERM:-x11 enhanced} title '$title' persist"
cmd=plot
forexpr=
grepcmd=
raise=
showhelp=
while getopts "3cf:g:hilo:s:rt:x:y:z:CF:GH:LMSX:Y:Z:" opt
do
  case $opt in
    3) cmd=splot
       ;;
    c) autotitle=true
       ;;
    f) forexpr=" for [$OPTARG] "
       ;;
    g) grepcmd="grep \"$OPTARG\""
       ;;
    h) showhelp=0
       ;;
    i) pause='pause -1 "Plot interactive until Enter pressed.\nHit h in plot window for help.\n"'
       ;;
    l) echo "set logscale y" >> $tmp2
       ;;
    o)
       outputfile="${OPTARG##*/}"
       outputext="${outputfile##*.}"
       case "$outputext" in
         eps|EPS)
           terminal='set term postscript eps enhanced color dashed rounded'
           ;;
         jpeg|JPEG|jpg|JPG)
           terminal='set term jpeg enhanced'
           ;;
         png|PNG)
           terminal='set term png enhanced'
           ;;
         svg|SVG)
           terminal='set term svg dynamic enhanced'
           ;;
         *)
           echo Output \"$OPTARG\" has unknown extension \"$outputext\" 1>&2
           exit 1
           ;;
       esac
       pause='' # Disable interactive on file output
       echo set output \"$OPTARG\" >> $tmp2
       ;;
    r) raise="-raise"
       ;;
    s) savescript="$OPTARG"
       ;;
    t) echo set title \"$OPTARG\" >> $tmp2
       ;;
    x) echo set xlabel \"$OPTARG\" >> $tmp2
       ;;
    y) echo set ylabel \"$OPTARG\" >> $tmp2
       ;;
    z) echo set zlabel \"$OPTARG\" >> $tmp2
       ;;
    C) echo "set datafile separator \",\"" >> $tmp2
       ;;
    F) pause="pause $OPTARG; replot; reread"
       ;;
    G) echo "set grid" >> $tmp2
       ;;
    H) echo "bw = $OPTARG"                                  >> $tmp2
       echo "set boxwidth bw"                               >> $tmp2
       echo "bin(x, width) = width*floor(x/width) + bw/2.0" >> $tmp2
       echo "set style fill solid 0.5"                      >> $tmp2
       ;;
    L) echo "set logscale x" >> $tmp2
       ;;
    M) echo set pm3d map >> $tmp2
       ;;
    S) stdin=true
       ;;
    X) echo set xrange \[$OPTARG\] >> $tmp2
       ;;
    Y) echo set yrange \[$OPTARG\] >> $tmp2
       ;;
    Z) echo set zrange \[$OPTARG\] >> $tmp2
       ;;
  esac
done
shift $((OPTIND-1))

if [ x$showhelp != x ]; then
    cat <<-HERE
Usage: gplot [OPTION]... (FILE|EXTGLOB) GNUPLOTCMD...
Use gnuplot to plot one or more files directly from the command line.

  -3             Perform 3D plotting using gnuplot's splot command.
  -c             Populate the key using autotitling.
  -f FOREXPR     Prepend a 'for [FOREXPR]' to the plotting command.
  -g PATTERN     Grep for PATTERN in the input processing only matches.
  -h             Show this help message.
  -i             Interactive plotting mode.  Hit 'h' on plot for help.
  -l             Use logarithmic scale for y axis.
  -o FILE        Save the plot to FILE with type chosen via the extension.
                 Encapsulated postscript (eps), PNG, JPEG, and SVG supported.
  -r             Have the window manager raise the plot window.
  -s FILE        Save the generated gnuplot commands as a script called FILE.
  -t TITLE       Set TITLE as the plot title.
  -x XLABEL      Specify XLABEL as the x axis label.
  -y YLABEL      Specify YLABEL as the y axis label.
  -z ZLABEL      Specify ZLABEL as the z axis label.
  -C             Process comma-separated value (CSV) data.
  -F FREQUENCY   Replot the inputs every FREQUENCY seconds.
  -G             Show grid lines.
  -H BW          Ease making histograms using binwidth BW; see examples.
  -L             Use logarithmic scale for x axis.
  -M             In conjunction with option -3, employ 'set pm3d map'.
  -S             Prior to plotting, read auxililary gnuplot from stdin.
  -X XLOW:XHIGH  Specify an explicit x axis range instead of autoscaling.
  -Y YLOW:YHIGH  Specify an explicit y axis range instead of autoscaling.
  -Z ZLOW:ZHIGH  Specify an explicit z axis range instead of autoscaling.

Examples (see gnuplot documentation for complete GNUPLOTCMD details):

  gplot -c -i foo.dat using 1:2 with linespoints
  gplot -s foo.gp -X 0:1 -Y 0:2 foo.dat using 1:2 with linespoints
  gplot -o foo.eps foo.dat using 1:2 with linespoints
  gplot -f i=2:5 -p foo.png foo.dat using 1:i with points
  gplot -3 restart\*.dat using '"x":"y":"z"'
  gplot -H 0.01 foo.dat using '(bin(\$1,bw)):(1.0)' smooth frequency with boxes
  gplot foo.dat using '9:(0.0001)' smooth kdensity

Input files compressed by bzip2, gzip, or xz are transparently decompressed.
Variable \$GNUTERM, defaulting to "x11 enhanced", sets the gnuplot terminal.
On error, the failing gnuplot script is shown.
HERE
    exit $showhelp
fi

# Set terminal
echo "$terminal" >> $tmp1

# Slurp any settings built up during getopt processing
cat $tmp2 >> $tmp1

# Obtain file(s) to plot from first argument using extended globbing
# Deliberately allow globbing to occur in this assignment
shopt -s extglob
declare -a files=($1)
shift

# Tweak autotitle based on options and incoming argument details
if [ "$autotitle" ]; then
    # Use columnheader option iff only one file provided
    if [ ${#files[@]} -eq 1 -a $cmd != splot ]; then
        echo 'set key autotitle columnheader' >> $tmp1
    else
        echo 'set key autotitle' >> $tmp1
    fi
else
    echo 'set key noautotitle' >> $tmp1
fi

# Possibly slurp standard input for further options
# FIXME Not working for 'echo foo | gplot'
if [ "$stdin" ]; then
    cat <&1 >> $tmp1
fi

# Build gnuplot script to plot possibly multiple files
declare -i count=0
for file in "${files[@]}"
do
    # Automatically add any required decompresser in a pipeline
    case $(file -ib "$file") in                                 #(
        application/x-bzip2\;*) datafile="< bzcat \"$file\""  ;;#(
        application/x-gzip\;*)  datafile="< zcat  \"$file\""  ;;#(
        application/x-xz\;*)    datafile="< xzcat \"$file\""  ;;
        *)                      datafile=$file
    esac
    # Incorporate any nontrivial grepcmd for this file
    if test -n "$grepcmd"; then
        if test \< = ${datafile:0:1}; then
            datafile+="| $grepcmd"           # Append to pipeline
        else
            datafile="< $grepcmd $datafile"  # Begin pipeline
        fi
    fi
    count+=1
    if [ $count -eq 1 ]; then
        echo "$cmd" "$forexpr" \'$datafile\' $* \\ >> $tmp1
    else
        echo "   "  , "$forexpr" \'$datafile\' $* \\ >> $tmp1
    fi
done
echo '' >> $tmp1

# If requested, save the plotting commands as an executable script
if [ "$savescript" ]; then
    echo '#!/usr/bin/env gnuplot' > "$savescript"
    cat "$tmp1" >> "$savescript"
    chmod a+x "$savescript"
fi

# If requested, add a pause command to the end of the script. Notice this was
# not added to the $savescript as it would be annoying in that context.
if [ "$pause" ]; then
    echo "$pause" >> $tmp1
fi

# Generate the plot
# Display the script when an error occurs to aid debugging
gnuplot $raise $tmp1 || cat $tmp1
