/*  SvnRev
 *
 *  This utility retrieves the highest number that follows the "$Id: $" keyword
 *  or a combination of the $Rev: $ and $Date: $ keywords. The Subversion
 *  version control system expands these keywords and keeps them up to date.
 *  For an example of the tag, see the end of this comment.
 *
 *  Details on the usage and the operation of this utility is available on-line
 *  at http://www.compuphase.com/svnrev.htm.
 *
 *
 *  Acknowledgements
 *
 *  The support for .java files is contributed by Tom McCann (tommc@spoken.com).
 *  The support for C# is contributed by Gunther Zander (gzander@gmx.li).
 *  The option for prefixing and/or suffixing the build number (in the string
 *  constant SVN_REVSTR) was suggested by Robert Nitzel.
 *
 *
 *  License
 *
 *  Copyright (c) 2005-2012, ITB CompuPhase (www.compuphase.com).
 *
 *  This software is provided "as-is", without any express or implied warranty.
 *  In no event will the authors be held liable for any damages arising from
 *  the use of this software.
 *
 *  Permission is granted to anyone to use this software for any purpose,
 *  including commercial applications, and to alter it and redistribute it
 *  freely, subject to the following restrictions:
 *
 *  1.  The origin of this software must not be misrepresented; you must not
 *      claim that you wrote the original software. If you use this software in
 *      a product, an acknowledgment in the product documentation would be
 *      appreciated but is not required.
 *  2.  Altered source versions must be plainly marked as such, and must not be
 *      misrepresented as being the original software.
 *  3.  This notice may not be removed or altered from any source distribution.
 *
 * Version: $Id: svnrev.c 4666 2012-02-27 10:30:58Z thiadmer $
 */

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#if defined __BORLANDC__
  #include <io.h>
#else
  #include <unistd.h>
#endif
#if !defined NOSQL
  #if defined __WATCOMC__
    #include <direct.h>
  #elif defined __BORLANDC__
    #include <dir.h>
  #endif
  #define SQLITE_MUTEX_NOOP
  #include "sqlite3.c"
#endif
#include "svnrev.h"


#if defined __WIN32__ || defined _Win32 || defined _WIN32 || defined WIN32
  #define DIRSEP '\\'
  #define strcasecmp  stricmp
#elif defined macintosh
  #define DIRSEP ':'
#else
  /* assume Linux/Unix */
  #define DIRSEP '/'
#endif

#define MAX_LINELENGTH      512
#define MAX_SYMBOLLENGTH    32
enum {
  LANG_C_CPP,   /* C/C++ format, a ".h" file */
  LANG_JAVA,
  LANG_CS,      /* C# format */
  LANG_PROP,
  LANG_ORACLE   /* Oracle package specification .sql */
};

#define SVN_SIGNATURE   "This file was generated by the \"svnrev\" utility"

static void about(void)
{
  printf("svnrev 2.0." SVN_REVSTR "\n\n");
  printf("Copyright 2005-2012 ITB CompuPhase. See http://www.compuphase.com/ for source\ncode and documentation\n\n");
  printf("Usage: svnrev [options] <input> [input [...]]\n\n"
         "Options:\n"
         "-jname\t\tJava: this option writes a java package file instead of a C/C++\n"
         "\t\theader file. The name of the Java package must follow the\n"
         "\t\toption (this is not the filename).\n\n"
         "-cname\t\tC#: this option writes a c-sharp class file instead of a C/C++\n"
         "\t\theader file. The name of the namespace and class must follow\n"
         "\t\tthe option. Namespace and class names are separated by a\n"
         "\t\tperiod (namespace.class).\n\n"
         "-Oname\t\tOracle: this option creates a Oracle package file instead of\n"
         "\t\ta C/C++ header file. The name of the package must follow the\n"
         "\t\toption.\n\n"
         "-P\t\tProperty file: This option creates a \"property file\", that can\n"
         "\t\tthen be used with ant.\n\n"
         "-pfilename\tC#: Assembly Property Filename (AssemblyInfo.cs)\n"
         "\t\tthe AssemblyVersion and AssemblyFileVersion will be updated.\n\n"
         "-ofilename\tOutput filename for the file with the build number. When no\n"
         "\t\tfilename follows \"-o\", the result is written to stdout. The\n"
         "\t\tdefault filename is \"svnrev.h\" for C/C++, \"SvnRevision.java\"\n"
         "\t\tfor Java and \"SvnRevision.cs\" for C#.\n\n"
         "-i\t\tIncremental: this option should be used when the list of input\n"
         "\t\tfiles is a subset of all files in the project. When -i is\n"
         "\t\tpresent, svnrev also scans the output file that was generated\n"
         "\t\ton a previous run.\n\n"
         "-fpattern\tFormat: adds text before or after the build number in the\n"
         "\t\tconstant SVN_REVSTR. The pattern has the form \"text#text\"\n"
         "\t\t(without the quotes) where \"text\" is arbitrary text and \"#\"\n"
         "\t\twill be replaced by the build number.\n\n"
         "-mname\t\tMacro prefix: by default all generated constants start with\n"
         "\t\tSVN_REV, but this can be changed with this option.\n\n"
         "-n\t\tIgnore line endings (CR versus LF versus CR+LF) when comparing\n"
         "\t\tthe working copy to the base.\n\n"
         "-v\t\tVerbose: prints the names of files that are modified since the\n"
         "\t\tlast commit (into version control) to stderr.\n");
  exit(1);
}

#if !defined NOSQL
static void strins(char *string, const char *sub)
{
  int sublen = strlen(sub);
  memmove(string + sublen, string, strlen(string) + 1);
  memmove(string, sub, sublen);
}

static char *strr2chr(const char *string, char ch)
{
  int idx = strlen(string) - 1;
  int count = 2;
  while (idx >= 0) {
    if (string[idx] == ch) {
      if (--count == 0)
        return (char*)string + idx;
    }
    idx--;
  }
  return NULL;
}

typedef struct tagPRISTINE_INFO {
  char *checksum;
  int revision;
  unsigned long timestamp;
} PRISTINE_INFO;

int sqlite_callback(void *user, int columns, char** strings, char** names)
{
  PRISTINE_INFO *info = user;

  assert(info != NULL);
  assert(columns == 3);
  assert(strings != NULL);
  (void)columns;
  (void)names;
  if (strings[0] != NULL)
    strcpy(info->checksum, strings[0]);
  if (strings[1] != NULL)
    info->revision = (int)strtol(strings[1], NULL, 10);
  if (strings[2] != NULL) {
    /* Subversion stores a time-stamp in microseconds; we are more than happy
     * to have seconds
     */
    sqlite_int64 stamp;
    sqlite3Atoi64(strings[2], &stamp, strlen(strings[2]), SQLITE_UTF8);
    info->timestamp = (unsigned long)(stamp / 1000000);
  }
  return 0;
}

static char *sqlite_dbname = NULL;
static sqlite3 *sqlite_db = NULL;

static void sqlite_opt_close(void)
{
  if (sqlite_db != NULL) {
    sqlite3_close(sqlite_db);
    sqlite_db = NULL;
  }
  if (sqlite_dbname != NULL) {
    free(sqlite_dbname);
    sqlite_dbname = NULL;
  }
}

static int sqlite_opt_open(const char *database)
{
  int err = SQLITE_OK;

  if (database == NULL) {
    /* close the current database, do not open another */
    sqlite_opt_close();
  } else {
    /* check whether a different database is currently open; if so, close it */
    assert(database != NULL);
    if (sqlite_dbname != NULL && strcasecmp(database, sqlite_dbname) != 0)
      sqlite_opt_close();
    /* open the (new) database, if any */
    if (sqlite_db == NULL) {
      err = sqlite3_open(database, &sqlite_db);
      if (err == SQLITE_OK) {
        sqlite_dbname = strdup(database);
        assert(sqlite_dbname != NULL);
      }
    }
  }
  return err;
}

static int sqlite_lookup(const char *database, const char *localname,
                         char *pristine, int *revision, unsigned long *timestamp)
{
  char query[512];
  char checksum[80] = "";
  char *ptr;
  char shard[10];
  PRISTINE_INFO info;
  char *zErrMsg = NULL;
  int err;

  assert(pristine != NULL);
  *pristine = '\0';
  assert(revision != NULL);
  *revision = 0;
  assert(timestamp != NULL);
  *timestamp = 0;

  assert(database != NULL);
  if (access(database, 0) != 0) {
    fprintf(stderr, "\tWarning: unable to find Subversion 1.7 'working copy' metadata.\n"
                    "\tThis directory may not be under version control.\n");
    return 0;
  }
  err = sqlite_opt_open(database);
  if (err != SQLITE_OK) {
    fprintf(stderr, "\tWarning: failed to open 'working copy' database for '%s'\n", localname);
    return 0;
  }

  assert(localname != NULL);
  sprintf(query, "SELECT checksum,changed_revision,changed_date FROM nodes WHERE local_relpath='%s';", localname);
  /* set up a structure to pass to the callback */
  info.checksum = checksum;
  info.revision = 0;
  info.timestamp = 0;
  err = sqlite3_exec(sqlite_db, query, sqlite_callback, &info, &zErrMsg);
  if (err != SQLITE_OK) {
    fprintf(stderr, "SQL error: %s\n", zErrMsg);
    sqlite3_free(zErrMsg);
    return 0;
  }

  if (strlen(checksum) == 0)
    return 0;

  assert(revision != NULL);
  *revision = info.revision;
  assert(timestamp != NULL);
  *timestamp = info.timestamp;

  /* manipulate the returned checksum to create a filename from it */
  strcpy(pristine, database);
  if ((ptr = strrchr(pristine, DIRSEP)) != NULL)
    *(ptr + 1) = '\0';
  else
    pristine[0] = '\0';
  strcat(pristine, "pristine");
  assert(strncmp(checksum, "$sha1$", 6) == 0);
  sprintf(shard, "%c%c%c%c", DIRSEP, checksum[6], checksum[7], DIRSEP);
  strcat(pristine, shard);
  strcat(pristine, checksum + 6);
  strcat(pristine, ".svn-base");

  return 1;
}
#endif  /* NOSQL */

static void processfile(const char *name, int failsilent, int ignore_eol,
                        int *max_build, int *accum_build,
                        int *max_year, int *max_month, int *max_day,
                        int *ismodified)

{
  #if !defined NOSQL
    char sqlite_path[MAX_LINELENGTH] = "";
  #endif
  char str[MAX_LINELENGTH], str_base[MAX_LINELENGTH];
  char name_base[MAX_LINELENGTH];
  char name_local[MAX_LINELENGTH];
  char *ptr, *base;
  FILE *fp, *fp_base;
  int build, maj_build;
  int year, month, day;
  int cnt, name_len;
  char modchar;
  unsigned long timestamp;

  build = 0;
  maj_build = 0;      /* RCS / CVS */
  year = month = day = 0;
  timestamp = 0;

  /* since we also want to verify whether the file is modified in version
   * control, get the path to the working copy name
   * in Subversion 1.6 (and earlier) working copies, the "pristine" copy of any
   * file "<path>\<filename> is in "<path>\.svn\text-base\<filename>.svn-base"
   * in Subversion 1.7, we need to go through the SQLite database to find the
   * path
   */
  if ((base = strrchr(name, DIRSEP)) != NULL) {
    ++base; /* skip directory separator character ('\' in Windows, '/' in Linux) */
    strncpy(name_base, name, (int)(base - name));
    name_base[(int)(base - name)] = '\0';
  } else {
    name_base[0] = '\0';
    base = (char*)name;
  } /* if */
  /* find the working copy & format */
  name_local[0] = '\0';
  name_len = strlen(name_base);
  sprintf(name_base + name_len, ".svn%centries", DIRSEP);
  if (access(name_base, 0) == 0) {
    /* check for the database */
    name_base[name_len] = '\0'; /* undo concatenation of .svn/entries */
    sprintf(name_base + name_len, ".svn%cwc.db", DIRSEP);
    if (access(name_base, 0) == 0) {
      #if !defined NOSQL
        strcpy(sqlite_path, name_base);
        strcat(name_local, base);
        while ((ptr = strchr(name_local, '\\')) != NULL)
          *ptr = '/';     /* Subversion stores the filenames in Unix format in its database */
        sqlite_lookup(sqlite_path, name_local, name_base, &build, &timestamp);
      #else
        fprintf(stderr, "\tWarning: this is a working copy for Subversion 1.7, but this version of SvnRev was built without version 1.7 support.\n");
        name_base[0] = '\0';
      #endif
    } else {
      /* working copy version 1.6 (or earlier) */
      sprintf(name_base + strlen(name_base), ".svn%ctext-base%c%s.svn-base",
              DIRSEP, DIRSEP, base);
    }
  } else {
    #if !defined NOSQL
      /* version 1.7, and this directory is not the root; go to the parent directory */
      do {
        name_base[name_len] = '\0'; /* undo concatenation of .svn/wc.db */
        if ((ptr = strr2chr(name_base, DIRSEP)) != NULL) {
          strins(name_local, ptr + 1);
          *(ptr + 1) = '\0';
        } else if (name_len > 0) {
          strins(name_local, name_base);
          name_base[0] = '\0';
        } else {
          break;          /* no more subdirectories and zero-length string already tried */
        }
        name_len = strlen(name_base);
        sprintf(name_base + name_len, ".svn%cwc.db", DIRSEP);
      } while (access(name_base, 0) != 0);
      if (access(name_base, 0) != 0) {
        /* so the working copy was not found in a named directory, go to the parent of this directory */
        getcwd(name_base, sizeof name_base);
        name_len = strlen(name_base);
        if (name_len > 0 && name_base[name_len-1] != DIRSEP) {
          name_base[name_len++] = DIRSEP;
          name_base[name_len] = '\0';
        }
        do {
          name_base[name_len] = '\0'; /* undo concatenation of .svn/wc.db */
          if ((ptr = strr2chr(name_base, DIRSEP)) != NULL) {
            strins(name_local, ptr + 1);
            *(ptr + 1) = '\0';
          } else if (name_len > 0) {
            strins(name_local, name_base);
            name_base[0] = '\0';
          } else {
            break;          /* no more subdirectories and zero-length string already tried */
          }
          name_len = strlen(name_base);
          sprintf(name_base + name_len, ".svn%cwc.db", DIRSEP);
        } while (access(name_base, 0) != 0);
      }
      strcpy(sqlite_path, name_base);
      strcat(name_local, base);
      while ((ptr = strchr(name_local, '\\')) != NULL)
        *ptr = '/';     /* Subversion stores the filenames in Unix format in its database */
      sqlite_lookup(sqlite_path, name_local, name_base, &build, &timestamp);
    #else
      fprintf(stderr, "\tWarning: this is a working copy for Subversion 1.7, but this version of SvnRev was built without version 1.7 support.\n");
      name_base[0] = '\0';
    #endif
  }
  if (timestamp != 0) {
    struct tm *lt = localtime((const time_t *)&timestamp);
    year = lt->tm_year + 1900;
    month = lt->tm_mon + 1;
    day = lt->tm_mday;
  }

  /* first extract the revision keywords */
  fp = fopen(name, "r");
  if (fp == NULL) {
    if (!failsilent)
      fprintf(stderr, "Failed to open input file '%s'\n", name);
    return;
  } /* if */
  fp_base = fopen(name_base, "r");  /* fail silently */

  while (fgets(str, sizeof str, fp) != NULL) {
    if (fp_base == NULL || fgets(str_base, sizeof str_base, fp_base) == NULL)
      str_base[0] = '\0';
    if ((ptr = strstr(str, "$Id:")) != NULL && strchr(ptr+1, '$') != NULL) {
      if (sscanf(ptr, "$Id: %*s %d %d-%d-%d", &build, &year, &month, &day) < 4
          && sscanf(ptr, "$Id: %*s %d %d/%d/%d", &build, &year, &month, &day) < 4)
        if (sscanf(ptr, "$Id: %*s %d.%d %d-%d-%d", &maj_build, &build, &year, &month, &day) < 5)
          sscanf(ptr, "$Id: %*s %d.%d %d/%d/%d", &maj_build, &build, &year, &month, &day);
    } else if ((ptr = strstr(str, "$Rev:")) != NULL && strchr(ptr+1, '$') != NULL) {
      if (sscanf(ptr, "$Rev: %d.%d", &maj_build, &build) < 2) {
        sscanf(ptr, "$Rev: %d", &build);
        maj_build = 0;
      } /* if */
    } else if ((ptr = strstr(str, "$Revision:")) != NULL && strchr(ptr+1, '$') != NULL) {
      if (sscanf(ptr, "$Revision: %d.%d", &maj_build, &build) < 2) {
        /* SvnRev also writes this keyword in its own generated file; read it
         * back for partial updates
         */
        cnt = sscanf(ptr, "$Revision: %d%c", &build, &modchar);
        if (cnt == 2 && modchar == 'M' && ismodified != NULL)
          *ismodified = 1;
        maj_build = 0;
      } /* if */
    } else if ((ptr = strstr(str, "$Date:")) != NULL && strchr(ptr+1, '$') != NULL) {
      if (sscanf(ptr, "$Date: %d-%d-%d", &year, &month, &day) < 3)
        sscanf(ptr, "$Date: %d/%d/%d", &year, &month, &day);
    } else if (ismodified != NULL && *ismodified == 0 && fp_base != NULL) {
      /* no keyword present, compare the lines for equivalence,
       * but (optionally) first cut off the strings at the first CR/LF character
       * (for cross-platform compatibility)
       */
      if (ignore_eol) {
        for (ptr = strchr(str, '\0'); ptr != NULL && ptr > str && (*(ptr - 1) == '\r' || *(ptr - 1) == '\n'); ptr--)
          *--ptr = '\0';
        for (ptr = strchr(str_base, '\0'); ptr != NULL && ptr > str_base && (*(ptr - 1) == '\r' || *(ptr - 1) == '\n'); ptr--)
          *--ptr = '\0';
      } /* if */
      *ismodified = strcmp(str, str_base) != 0;
    } /* if */

    if (maj_build)
      *accum_build += build;            /* RCS / CVS */
    else if (build > *max_build)
      *max_build = build;               /* Subversion */
    if (year > *max_year
        || (year == *max_year && month > *max_month)
        || (year == *max_year && month == *max_month && day > *max_day))
    {
        *max_year = year;
        *max_month = month;
        *max_day = day;
    } /* if */
    if (build > 0 && year > 0 && !failsilent
        && (fp_base == NULL || ismodified == NULL || *ismodified != 0))
      break;      /* both build # and date found, either not comparing for
                   * modification or already found => no need to search further */

  } /* while */
  fclose(fp);
  if (fp_base != NULL)
    fclose(fp_base);
}

static int scanmodifications(const char *filename, const char *basename)
{
  FILE *fp;
  char str[MAX_LINELENGTH];
  char constant[128];
  char *ptr;
  size_t constlen;
  int modifcount = 0;

  if ((fp = fopen(filename, "r")) == NULL)
    return 0;

  sprintf(constant, "%sMODIFIED", basename);
  constlen = strlen(constant);
  while (fgets(str, sizeof str, fp) != NULL) {
    if ((ptr = strstr(str, constant)) != NULL && ptr > str && *(ptr - 1) <= ' ' && *(ptr + constlen) <= ' ')
      modifcount = strtol(ptr + constlen, NULL, 10);
  } /* while */

  fclose(fp);
  return modifcount;
}

static void get_buildno_ptr(char **start, char **stop)
{
  int rem_points = 3;
  char *stop_old = *stop;

  while(rem_points > 0 && *start < stop_old)
  {
    while(**start != '.' && *start < stop_old)
    {
      (*start)++;
    }
    (*start)++;
    rem_points--;
  }
  *stop = *start;
  while(**stop != '"' && *stop < stop_old) (*stop)++;
}

static void update_prop_file(char *filename, int rev)
{
  char line[512];
  char fileout[128];
  char *out;
  char *outComment;
  char *outVersion;
  char *outFileVersion;
  FILE *fsource;
  FILE *fdest;

  if(filename == NULL || strlen(filename) == 0)
  {
    return;
  }

  if((fsource = fopen(filename, "r+")) == NULL)
  {
    fprintf(stderr, "Failed to open output file '%s'\n", filename);
    return;
  }

  sprintf(fileout, "%s.tmp", filename);
  if((fdest = fopen(fileout, "w")) == NULL)
  {
    fprintf(stderr, "Failed to create output file '%s'\n", fileout);
    fclose(fsource);
    return;
  }

  /*
  look for these two lines:
  [assembly: AssemblyVersion("1.2.3.4")]
  [assembly: AssemblyFileVersion("1.2.3.4")]
  */

  while((out = fgets(line, 512, fsource)) != NULL)
  {
    outComment = strstr(line, "//");
    outVersion = strstr(line, "AssemblyVersion");
    outFileVersion = strstr(line, "AssemblyFileVersion");
    if(outVersion == NULL && outFileVersion == NULL)
    {
      fputs(line, fdest);
      continue;
    }

    if(outVersion != NULL)
    {
      if(outComment == NULL || outComment > outVersion)
      {
        char *start, *stop;
        char buffer[512];
        start = outVersion + strlen("AssemblyVersion") + 2;
        stop = start + strlen(start) - 1;
        get_buildno_ptr(&start, &stop);
        strcpy(buffer, stop);
        sprintf(start, "%i%s", rev, buffer);
        fputs(line, fdest);
      }
      else
      {
        fputs(line, fdest);
        continue;
      }
    }

    if(outFileVersion != NULL)
    {
      if(outComment == NULL || outComment > outFileVersion)
      {
        char *start, *stop;
        char buffer[512];
        start = outFileVersion + strlen("AssemblyFileVersion") + 2;
        stop = start + strlen(start) - 1;
        get_buildno_ptr(&start, &stop);
        strcpy(buffer, stop);
        sprintf(start, "%i%s", rev, buffer);
        fputs(line, fdest);
      }
      else
      {
        fputs(line, fdest);
        continue;
      }
    }
  }

  fclose(fsource);
  fclose(fdest);

  remove(filename);
  rename(fileout, filename);

  (void)out;  /* to avoid a compiler warning */
}

int main(int argc, char *argv[])
{
  char *outname = NULL;
  FILE *fp;
  int index;
  int process_self = 0;
  int verbose = 0;
  int ignore_eol = 0;
  int build_nr = 1;
  int max_build, accum_build;
  int max_year, max_month, max_day;
  int svn_build, accum_svnbuild;
  int svn_year, svn_month, svn_day;
  int ismodified, filemodified, modificationcount;
  char prefix[MAX_SYMBOLLENGTH], suffix[MAX_SYMBOLLENGTH];
  char *const_basename = NULL;
  char modified_suffix[2];
  int output_language = LANG_C_CPP;   /* flag for C/C++, Java or C# output */
  char *namespace_name = NULL;        /* java package or C# namespace to put revision info in */
  char *propname = NULL;
  char *startComment;
  char *endComment;
  char *continueComment;

  if (argc <= 1)
    about();

  /* collect the options */
  prefix[0] = '\0';
  suffix[0] = '\0';

  for (index = 1; index < argc; index++) {
    /* check for options */
    if (argv[index][0] == '-'
#if defined __WIN32__ || defined _Win32 || defined _WIN32
     || argv[index][0] == '/'
#endif
    )
    {
      switch (argv[index][1]) {
      case 'j':
        output_language = LANG_JAVA;
        namespace_name = &argv[index][2];
        break;
      case 'c':
        output_language = LANG_CS;
        namespace_name = &argv[index][2];
        break;
      case 'P':
        output_language = LANG_PROP;
        break;
      case 'O':
        output_language = LANG_ORACLE;
        namespace_name = &argv[index][2];
        break;
      case 'b':
        build_nr = 0;
        break;
      case 'f': {
        size_t len;
        char *ptr = strchr(&argv[index][2], '#');
        len = (ptr != NULL) ? (int)(ptr - &argv[index][2]) : (int)strlen(&argv[index][2]);
        if (len >= MAX_SYMBOLLENGTH)
          len = MAX_SYMBOLLENGTH - 1;
        strncpy(prefix, &argv[index][2], len);
        prefix[len] = '\0';
        ptr = (ptr != NULL) ? ptr + 1 : strchr(argv[index], '\0');
        len = strlen(ptr);
        if (len >= MAX_SYMBOLLENGTH)
          len = MAX_SYMBOLLENGTH - 1;
        strncpy(suffix, ptr, len);
        suffix[len] = '\0';
        break;
      } /* case */
      case 'i':
        process_self = 1;
        break;
      case 'm':
        const_basename = &argv[index][2];
        break;
      case 'n':
        ignore_eol = 1;
        break;
      case 'o':
        outname = &argv[index][2];
        break;
      case 'p':
        propname = &argv[index][2];
        break;
      case 'v':
        verbose = 1;
        break;
      default:
        fprintf(stderr, "Invalid option '%s'\n", argv[index]);
        about();
      } /* switch */
    } /* if */
  } /* for */

  if (outname == NULL) {
    switch (output_language) {
    case LANG_C_CPP:
      outname = "svnrev.h";
      break;
    case LANG_JAVA:
      outname = "SvnRevision.java";
      break;
    case LANG_CS:
      outname = "SvnRevision.cs";
      break;
    case LANG_PROP:
      outname = "svnrev.property";
      break;
    case LANG_ORACLE:
      outname = "svnrev.sql";
      break;
    } /* switch */
  } /* if */

  /* scan through the existing svnrev header file to find the "build" count */
  if (const_basename == NULL || *const_basename == '\0')
    const_basename = "SVN_REV";
  assert(outname != NULL);
  modificationcount = scanmodifications(outname, const_basename);
  /* run over the current svnrev header file to find the base version number;
   * this is also used as the starting number of the build version for an
   * incremental scan
   */
  svn_build = 0;
  accum_svnbuild = 0;   /* for RCS / CVS */
  svn_year = svn_month = svn_day = 0;
  if (*outname != '\0')
    processfile(outname, 1, ignore_eol, &svn_build, &accum_svnbuild, &svn_year, &svn_month, &svn_day, NULL/*&ismodified*/);

  /* phase 1: scan through all files and get the highest build number */
  if (process_self) {
    max_build = svn_build;
    accum_build = accum_svnbuild;
    max_year = svn_year;
    max_month = svn_month;
    max_day = svn_day;
  } else {
    max_build = 0;
    accum_build = 0;      /* for RCS / CVS */
    max_year = max_month = max_day = 0;
  }
  ismodified = 0;
  for (index = 1; index < argc; index++) {
    /* skip the options (already handled) */
    if (argv[index][0] == '-'
#if defined __WIN32__ || defined _Win32 || defined _WIN32
        || argv[index][0] == '/'
#endif
    )
      continue;

    /* skip the output file we will be writing (it was already handled in
       incremental mode, and it SHOULD NOT be handled in non-incremental mode) */
    if (strcasecmp(argv[index],outname) == 0)
      continue;

    filemodified = 0;
    processfile(argv[index], 0, ignore_eol, &max_build, &accum_build, &max_year, &max_month, &max_day, &filemodified);
    if (filemodified && verbose)
      fprintf(stderr, "\tNotice: modified file '%s'\n", argv[index]);
    ismodified = ismodified || filemodified;
  } /* for */
  sqlite_opt_close();

  if (accum_build > max_build)
    max_build = accum_build;
  modified_suffix[0] = (char)(ismodified ? 'M' : '\0');
  modified_suffix[1] = '\0';
  if (!build_nr)
    modificationcount = 0;

  /* phase 2: write a file with this highest build number */
  if (max_build == svn_build && accum_build == accum_svnbuild
      && max_year == svn_year && max_month == svn_month && max_day == svn_day
      && (!ismodified || !build_nr)
      && *outname != '\0' && access(outname, 0) == 0)
    return 0; /* no changes have been detected and the file to create already exists */
  if (*outname == '\0') {
    fp = stdout;
  } else if ((fp = fopen(outname, "w")) == NULL) {
    fprintf(stderr, "Failed to create output file '%s'\n", outname);
    return 2;
  } /* if */
  if (*outname != '\0') {
    switch (output_language) {
    case LANG_C_CPP:
    case LANG_JAVA:
    case LANG_CS:
      startComment = "/* ";
      endComment = " */";
      continueComment = " * ";
      break;
    case LANG_ORACLE:
      startComment = "-- ";
      endComment = "-- ";
      continueComment = "-- ";
      break;
    case LANG_PROP:
      startComment = "# ";
      endComment = "# ";
      continueComment = "# ";
      break;
    } /* switch */
    /* don't print the comments to stdout */
    fprintf(fp, "%s%s\n"
                "%s(http://www.compuphase.com/svnrev.htm).\n"
                "%sYou should not modify it manually, as it may be re-generated.\n"
                "%s\n"
                "%s$Revision: %d%s$\n"
                "%s$Date: %04d-%02d-%02d$\n"
                "%s\n\n", startComment, SVN_SIGNATURE, continueComment, continueComment, continueComment,
                  continueComment,  max_build,
              modified_suffix, continueComment, max_year, max_month, max_day,endComment);
  } /* if */

  switch (output_language) {
  case LANG_C_CPP:
    fprintf(fp, "#ifndef %s_H\n", const_basename);
    fprintf(fp, "#define %s_H\n\n", const_basename);
    fprintf(fp, "#define %s\t\t%d\n", const_basename, max_build);
    fprintf(fp, "#define %sSTR\t\"%s%d%s%s\"\n", const_basename, prefix, max_build, modified_suffix, suffix);
    fprintf(fp, "#define %sDATE\t\"%04d-%02d-%02d\"\n", const_basename, max_year, max_month, max_day);
    fprintf(fp, "#define %sSTAMP\t%04d%02d%02dL\n", const_basename, max_year, max_month, max_day);
    fprintf(fp, "#define %sMODIFIED\t%d\n", const_basename, ismodified ? modificationcount + 1 : 0);
    fprintf(fp, "\n#endif /* %s_H */\n", const_basename);
    break;
  case LANG_JAVA:
    if (namespace_name == NULL || *namespace_name == '\0')
      namespace_name = "com.compuphase";
    fprintf(fp, "package %s;\n\n", namespace_name);
    fprintf(fp, "public interface SvnRevision\n");
    fprintf(fp, "{\n");
    fprintf(fp, "    public final static int %s = %d;\n", const_basename, max_build);
    fprintf(fp, "    public final static String %sSTR = \"%s%d%s%s\";\n", const_basename, prefix, max_build, modified_suffix, suffix);
    fprintf(fp, "    public final static String %sDATE = \"%04d-%02d-%02d\";\n", const_basename, max_year, max_month, max_day);
    fprintf(fp, "    public final static long %sSTAMP = %04d%02d%02dL;\n", const_basename, max_year, max_month, max_day);
    fprintf(fp, "    public final static int %sMODIFIED = %d;\n", const_basename, ismodified ? modificationcount + 1 : 0);
    fprintf(fp, "}\n\n");
    break;
  case LANG_CS: {
    char *cls;
    if (namespace_name == NULL || (cls = strrchr(namespace_name, '.')) == NULL) {
      namespace_name = "compuphase";
      cls = "svnrev";
    } else {
      *cls++ = '\0';
    } /* if */
    fprintf(fp, "using System;\n\n");
    fprintf(fp, "namespace %s\n{\n", namespace_name);
    fprintf(fp, "\tpublic static partial class %s\n", cls);
    fprintf(fp, "\t{\n");
    fprintf(fp, "\t\tpublic const Int32  %s = %d;\n", const_basename, max_build);
    fprintf(fp, "\t\tpublic const String %sSTR = \"%s%d%s%s\";\n", const_basename, prefix, max_build, modified_suffix, suffix);
    fprintf(fp, "\t\tpublic const String %sDATE = \"%04d-%02d-%02d\";\n", const_basename, max_year, max_month, max_day);
    fprintf(fp, "\t\tpublic const Int64  %sSTAMP = %04d%02d%02d;\n", const_basename, max_year, max_month, max_day);
    fprintf(fp, "\t\tpublic const Int32  %sMODIFIED = %d;\n", const_basename, ismodified ? modificationcount + 1 : 0);
    fprintf(fp, "\t}\n}\n");
    update_prop_file(propname, max_build);
    break;
  } /* case */
  case LANG_PROP:
    fprintf(fp, "%s = %d\n", const_basename, max_build);
    fprintf(fp, "%sSTR = %s%d%s%s\n", const_basename, prefix, max_build, modified_suffix, suffix);
    fprintf(fp, "%sDATE = %04d-%02d-%02d\n", const_basename, max_year, max_month, max_day);
    fprintf(fp, "%sSTAMP = %04d%02d%02dL\n", const_basename, max_year, max_month, max_day);
    fprintf(fp, "%sMODIFIED = %d\n", const_basename, ismodified ? modificationcount + 1 : 0);
    break;
  case LANG_ORACLE:
    if (namespace_name == NULL || *namespace_name == '\0')
      namespace_name = "compuphase";
    fprintf( fp, "create or replace package %s\n", namespace_name);
    fprintf( fp, "as\n" );
    fprintf(fp, "\t%s CONSTANT INT := %d;\n", const_basename, max_build);
    fprintf(fp, "\t%sSTR CONSTANT VARCHAR2(200) := \"%s%d%s%s\";\n", const_basename, prefix, max_build, modified_suffix, suffix);
    fprintf(fp, "\t%sDATE CONSTANT DATE := TO_DATE('%04d-%02d-%02d','YYYY-MM-DD');\n", const_basename, max_year, max_month, max_day);
    fprintf(fp, "\t%sSTAMP CONSTANT INT := %04d%02d%02d;\n", const_basename, max_year, max_month, max_day);
    fprintf(fp, "\t%sMODIFIED CONSTANT INT := %d;\n", const_basename, ismodified ? modificationcount + 1 : 0);
    fprintf(fp, "END %s;\n/\n\nshow errors\n\n", namespace_name);
    break;
  } /* switch */

  if (*outname != '\0')
    fclose(fp);

  return 0;
}
