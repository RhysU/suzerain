#ifdef HAVE_CONFIG_H
#include <suzerain/config.h>
#endif
#include <suzerain/common.hpp>
#include <suzerain/pencilfft.hpp>
#pragma hdrstop
#define BOOST_TEST_MODULE $Id$
#include <boost/assign.hpp>
#include <boost/mpl/list_c.hpp>
#include <boost/test/included/unit_test.hpp>
#include <boost/test/test_case_template.hpp>
#include <fftw3.h>
#include "test_tools.hpp"

#pragma warning(disable:383)

typedef boost::mpl::list_c<int,0,1> int_zero_one_type;

using namespace suzerain;

BOOST_AUTO_TEST_SUITE( increment )

using pencilfft::detail::increment;

BOOST_AUTO_TEST_CASE( increment_1d_degenerate )
{
    const int n        = 1;
    int       index[n] = { 0 };
    const int shape[n] = { 1 };

    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), false);
}

BOOST_AUTO_TEST_CASE( increment_1d_normal )
{
    const int n        = 1;
    int       index[n] = { 0 };
    const int shape[n] = { 3 };

    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 2);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), false);
}

BOOST_AUTO_TEST_CASE( increment_1d_normal_unsigned )
{
    const unsigned int n        = 1;
    unsigned int       index[n] = { 0 };
    const unsigned int shape[n] = { 3 };

    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 2);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), false);
}

BOOST_AUTO_TEST_CASE( increment_2d_degenerate_first )
{
    const int           n     = 2;
    boost::array<int,n> index_array       = {{ 0, 0 }};
    const boost::array<int,n> shape_array = {{ 3, 1 }};
    boost::array<int,n>::iterator       index = index_array.begin();
    boost::array<int,n>::const_iterator shape = shape_array.begin();

    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(1)(0));

    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(2)(0));

    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), false);
}

BOOST_AUTO_TEST_CASE( increment_2d_degenerate_second )
{
    const int                   n     = 2;
    boost::array<int, n> index_array            = {{ 0, 0 }};
    boost::array<std::size_t,n> shape_array     = {{ 1, 3 }};
    boost::array<int, n>::iterator index        = index_array.begin();
    boost::array<std::size_t,n>::iterator shape = shape_array.begin();

    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(1));

    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(2));

    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), false);
}

BOOST_AUTO_TEST_CASE( increment_2d_degenerate_all )
{
    const int  n        = 2;
    int        index[n] = { 0, 0 };
    const long shape[n] = { 1, 1 };

    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), false);
}

BOOST_AUTO_TEST_CASE( increment_2d_normal )
{
    const int    n        = 2;
    unsigned int index[n] = { 0, 0 };
    unsigned int shape[n] = { 2, 3 };

    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 2);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 2);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), false);
}

BOOST_AUTO_TEST_CASE( increment_2d_normal_usualorder )
{
    const int    n        = 2;
    unsigned int index[n] = { 0, 0 };
    unsigned int shape[n] = { 2, 3 };
    unsigned int order[n] = { 0, 1 };

    BOOST_REQUIRE_EQUAL(increment<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 2);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 2);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape,order), false);
}

BOOST_AUTO_TEST_CASE( increment_2d_normal_reverseorder )
{
    const int    n        = 2;
    unsigned int index[n] = { 0, 0 };
    unsigned int shape[n] = { 2, 3 };
    unsigned int order[n] = { 1, 0 };

    BOOST_REQUIRE_EQUAL(increment<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 2);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 2);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape,order), false);
}

BOOST_AUTO_TEST_CASE( increment_3d_degenerate_all )
{
    const int         n        = 3;
    signed int        index[n] = { 0, 0, 0 };
    const signed long shape[n] = { 1, 1, 1 };

    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), false);
}

BOOST_AUTO_TEST_CASE( increment_3d_degenerate_middle )
{
    const int                                   n           = 3;
    long                                        index[n]    =  { 0, 0, 0 };
    const boost::array<std::size_t,n>           shape_array = {{ 3, 1, 3 }};
    boost::array<std::size_t,n>::const_iterator shape       = shape_array.begin();

    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 2);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 2);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 2);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 2);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 2);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 2);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), false);
}

BOOST_AUTO_TEST_CASE( increment_3d_normal )
{
    const int n = 3;
    std::vector<short> index_array(n, 0);
    std::vector<int>   shape_array(n, 2);
    std::vector<short>::iterator     index = index_array.begin();
    std::vector<int>::const_iterator shape = shape_array.begin();

    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape), false);
}

BOOST_AUTO_TEST_CASE( increment_3d_normal_outoforder )
{
    const int n = 3;
    boost::array<short,3> index_array = {{ 0, 0, 0 }};
    boost::array<int,3>   shape_array = {{ 2, 1, 3 }};
    boost::array<long,3>  order_array = {{ 2, 0, 1 }};

    boost::array<short,3>::iterator index = index_array.begin();
    boost::array<int,3>::iterator   shape = shape_array.begin();
    boost::array<long,3>::iterator  order = order_array.begin();

    BOOST_REQUIRE_EQUAL(increment<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 2);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 2);
    BOOST_REQUIRE_EQUAL(increment<n>(index,shape,order), false);
}

BOOST_AUTO_TEST_SUITE_END()

BOOST_AUTO_TEST_SUITE( decrement )

using pencilfft::detail::decrement;

BOOST_AUTO_TEST_CASE( decrement_1d_degenerate )
{
    const int n        = 1;
    int       index[n] = { 0 };
    const int shape[n] = { 1 };

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), false);
}

BOOST_AUTO_TEST_CASE( decrement_1d_normal )
{
    const int n        = 1;
    int       index[n] = { 2 };
    const int shape[n] = { 3 };

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), false);
}

BOOST_AUTO_TEST_CASE( decrement_1d_normal_unsigned )
{
    const unsigned int n        = 1;
    unsigned int       index[n] = { 2 };
    const unsigned int shape[n] = { 3 };

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), false);
}

BOOST_AUTO_TEST_CASE( decrement_2d_degenerate_first )
{
    const int n = 2;
    boost::array<int,n> index_array = {{ 2, 0 }};
    boost::array<int,n> shape_array = {{ 3, 1 }};
    boost::array<int,n>::iterator index = index_array.begin();
    boost::array<int,n>::iterator shape = shape_array.begin();

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), false);
}

BOOST_AUTO_TEST_CASE( decrement_2d_degenerate_second )
{
    const int n = 2;
    boost::array<int, n> index_array            = {{ 0, 2 }};
    boost::array<std::size_t,n> shape_array     = {{ 1, 3 }};
    boost::array<int, n>::iterator index        = index_array.begin();
    boost::array<std::size_t,n>::iterator shape = shape_array.begin();

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), false);
}

BOOST_AUTO_TEST_CASE( decrement_2d_degenerate_all )
{
    const int  n        = 2;
    int        index[n] = { 0, 0 };
    const long shape[n] = { 1, 1 };

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), false);
}

BOOST_AUTO_TEST_CASE( decrement_2d_normal )
{
    const int    n        = 2;
    unsigned int index[n] = { 1, 2 };
    unsigned int shape[n] = { 2, 3 };

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 2);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), false);
}

BOOST_AUTO_TEST_CASE( decrement_2d_normal_usualorder )
{
    const int    n        = 2;
    unsigned int index[n] = { 1, 2 };
    unsigned int shape[n] = { 2, 3 };
    unsigned int order[n] = { 0, 1 };

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 2);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), false);
}

BOOST_AUTO_TEST_CASE( decrement_2d_normal_reverseorder )
{
    const int    n        = 2;
    unsigned int index[n] = { 1, 2 };
    unsigned int shape[n] = { 2, 3 };
    unsigned int order[n] = { 1, 0 };

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 2);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), false);
}

BOOST_AUTO_TEST_CASE( decrement_3d_degenerate_all )
{
    const int         n        = 3;
    signed int        index[n] = { 0, 0, 0 };
    const signed long shape[n] = { 1, 1, 1 };

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), false);
}

BOOST_AUTO_TEST_CASE( decrement_3d_degenerate_middle )
{
    const int                   n               = 3;
    long                        index[n]        =  { 2, 0, 2 };
    boost::array<std::size_t,n> shape_array     = {{ 3, 1, 3 }};
    boost::array<std::size_t,n>::iterator shape = shape_array.begin();

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 2);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 2);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 2);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 2);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), false);
}

BOOST_AUTO_TEST_CASE( decrement_3d_normal )
{
    const int n = 3;
    std::vector<short> index_array(n, 1);
    std::vector<int>   shape_array(n, 2);
    std::vector<short>::iterator     index = index_array.begin();
    std::vector<int>::const_iterator shape = shape_array.begin();

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape), false);
}

BOOST_AUTO_TEST_CASE( decrement_3d_normal_outoforder )
{
    const int n = 3;
    boost::array<short,3> index_array = {{ 1, 0, 2 }};
    boost::array<int,3>   shape_array = {{ 2, 1, 3 }};
    boost::array<long,3>  order_array = {{ 2, 0, 1 }};

    boost::array<short,3>::iterator index = index_array.begin();
    boost::array<int,3>::iterator   shape = shape_array.begin();
    boost::array<long,3>::iterator  order = order_array.begin();

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 2);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), false);
}

BOOST_AUTO_TEST_CASE( decrement_3d_spot_check_behavior_1 )
{
    const int n = 3;
    typedef boost::array<int,n> array_type;
    array_type           index_array = {{ 3, 0, 1 }};
    array_type::iterator index       = index_array.begin();
    array_type           shape_array = {{ 4, 1, 2 }};
    array_type::iterator shape       = shape_array.begin();
    array_type           order_array = {{ 0, 1, 2 }};
    array_type::iterator order       = order_array.begin();

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(2)(0)(1));

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(1)(0)(1));

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(0)(1));

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(3)(0)(0));

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(2)(0)(0));

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(1)(0)(0));

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(0)(0));

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), false);
}

BOOST_AUTO_TEST_CASE( decrement_3d_spot_check_behavior_2 )
{
    const int n = 3;
    typedef boost::array<int,n> array_type;
    array_type           index_array = {{ 3, 0, 1 }};
    array_type::iterator index       = index_array.begin();
    array_type           shape_array = {{ 4, 1, 2 }};
    array_type::iterator shape       = shape_array.begin();
    array_type           order_array = {{ 2, 1, 0 }};
    array_type::iterator order       = order_array.begin();

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(3)(0)(0));

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(2)(0)(1));

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(2)(0)(0));

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(1)(0)(1));

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(1)(0)(0));

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(0)(1));

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), true);
    BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(0)(0));

    BOOST_REQUIRE_EQUAL(decrement<n>(index,shape,order), false);
}

BOOST_AUTO_TEST_SUITE_END()

BOOST_AUTO_TEST_SUITE( crement )

using pencilfft::detail::crement;

BOOST_AUTO_TEST_CASE( increment_1d_degenerate )
{
    const int  n             = 1;
    int        index[n]      = { 0 };
    const bool increasing[n] = { true };
    const int  shape[n]      = { 1 };

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), false);
}

BOOST_AUTO_TEST_CASE( increment_1d_normal )
{
    const int  n             = 1;
    int        index[n]      = { 0 };
    const bool increasing[n] = { true };
    const int  shape[n]      = { 3 };

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 2);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), false);
}

BOOST_AUTO_TEST_CASE( increment_1d_normal_unsigned )
{
    const unsigned int n             = 1;
    unsigned int       index[n]      = { 0 };
    const bool         increasing[n] = { true };
    const unsigned int shape[n]      = { 3 };

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 2);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), false);
}

BOOST_AUTO_TEST_CASE( increment_2d_degenerate_first )
{
    const int           n     = 2;
    boost::array<int,n> index_array                = {{ 0, 0 }};
    const boost::array<int,n> increasing_array     = {{ 1, 1 }};
    const boost::array<int,n> shape_array          = {{ 3, 1 }};
    boost::array<int,n>::iterator index            = index_array.begin();
    boost::array<int,n>::const_iterator increasing = increasing_array.begin();
    boost::array<int,n>::const_iterator shape      = shape_array.begin();

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(1)(0));

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(2)(0));

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), false);
}

BOOST_AUTO_TEST_CASE( increment_2d_degenerate_second )
{
    const int n = 2;
    boost::array<int, n> index_array                = {{ 0, 0 }};
    const boost::array<bool,n> increasing_array     = {{ true, true }};
    boost::array<std::size_t,n> shape_array         = {{ 1, 3 }};
    boost::array<int, n>::iterator index            = index_array.begin();
    boost::array<bool,n>::const_iterator increasing = increasing_array.begin();
    boost::array<std::size_t,n>::iterator shape     = shape_array.begin();

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(1));

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(2));

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), false);
}

BOOST_AUTO_TEST_CASE( increment_2d_degenerate_all )
{
    const int  n             = 2;
    int        index[n]      = { 0, 0 };
    bool       increasing[n] = { true, true };
    const long shape[n]      = { 1, 1 };

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), false);
}

BOOST_AUTO_TEST_CASE( increment_2d_normal )
{
    const int    n             = 2;
    unsigned int index[n]      = { 0, 0 };
    unsigned int increasing[n] = { 5, 57 };
    unsigned int shape[n]      = { 2, 3 };

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 2);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 2);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), false);
}

BOOST_AUTO_TEST_CASE( increment_2d_normal_usualorder )
{
    const int    n             = 2;
    unsigned int index[n]      = { 0, 0 };
    unsigned int increasing[n] = { 5, 57 };
    unsigned int shape[n]      = { 2, 3 };
    unsigned int order[n]      = { 0, 1 };

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 2);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 2);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), false);
}

BOOST_AUTO_TEST_CASE( increment_2d_normal_reverseorder )
{
    const int    n             = 2;
    unsigned int index[n]      = { 0, 0 };
    const bool   increasing[n] = { true, true };
    unsigned int shape[n]      = { 2, 3 };
    unsigned int order[n]      = { 1, 0 };

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 2);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 2);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), false);
}

BOOST_AUTO_TEST_CASE( increment_3d_degenerate_all )
{
    const int         n             = 3;
    signed int        index[n]      = { 0, 0, 0 };
    const signed long increasing[n] = { 1, 1, 1 };
    const signed long shape[n]      = { 1, 1, 1 };

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), false);
}

BOOST_AUTO_TEST_CASE( increment_3d_degenerate_middle )
{
    const int n = 3;
    long index[n] = { 0, 0, 0 };
    boost::array<std::size_t,n> increasing_array = {{ 3, 1, 3 }};
    boost::array<std::size_t,n>::const_iterator increasing = increasing_array.begin();
    const boost::array<std::size_t,n> shape_array = {{ 3, 1, 3 }};
    boost::array<std::size_t,n>::const_iterator shape = shape_array.begin();

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 2);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 2);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 2);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 2);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 2);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 2);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), false);
}

BOOST_AUTO_TEST_CASE( increment_3d_normal )
{
    const int n = 3;
    std::vector<short> index_array(n, 0);
    const std::vector<bool>  increasing_array(n, 1);
    const std::vector<int>   shape_array(n, 2);
    std::vector<short>::iterator      index      = index_array.begin();
    std::vector<bool>::const_iterator increasing = increasing_array.begin();
    std::vector<int>::const_iterator  shape      = shape_array.begin();

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), false);
}

BOOST_AUTO_TEST_CASE( increment_3d_normal_outoforder )
{
    const int n = 3;
    boost::array<short,3> index_array            = {{ 0, 0, 0 }};
    const boost::array<long,3>  increasing_array = {{ -1, -1, -1 }};
    const boost::array<int,3>   shape_array      = {{ 2, 1, 3 }};
    const boost::array<long,3>  order_array      = {{ 2, 0, 1 }};


    boost::array<short,3>::iterator index = index_array.begin();
    boost::array<long,3>::const_iterator increasing = increasing_array.begin();
    boost::array<int,3>::const_iterator  shape = shape_array.begin();
    boost::array<long,3>::const_iterator order = order_array.begin();

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 2);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 2);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), false);
}

BOOST_AUTO_TEST_CASE( decrement_1d_degenerate )
{
    const int n             = 1;
    int       index[n]      = { 0 };
    int       increasing[n] = { 0 };
    const int shape[n]      = { 1 };

    BOOST_REQUIRE_EQUAL(
        crement<n>(index,increasing,shape), false);
}

BOOST_AUTO_TEST_CASE( decrement_1d_normal )
{
    const int n             = 1;
    int       index[n]      = { 2 };
    int       increasing[n] = { 0 };
    const int shape[n]      = { 3 };

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), false);
}

BOOST_AUTO_TEST_CASE( decrement_1d_normal_unsigned )
{
    const unsigned int n             = 1;
    unsigned int       index[n]      = { 2 };
    unsigned int       increasing[n] = { 0 };
    const unsigned int shape[n]      = { 3 };

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), false);
}

BOOST_AUTO_TEST_CASE( decrement_2d_degenerate_first )
{
    const int n = 2;
    boost::array<int,n> index_array = {{ 2, 0 }};
    const boost::array<int,n> increasing_array = {{ 0, 0 }};
    const boost::array<int,n> shape_array = {{ 3, 1 }};
    boost::array<int,n>::iterator index = index_array.begin();
    boost::array<int,n>::const_iterator increasing = increasing_array.begin();
    boost::array<int,n>::const_iterator shape = shape_array.begin();

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), false);
}

BOOST_AUTO_TEST_CASE( decrement_2d_degenerate_second )
{
    const int n = 2;
    boost::array<int, n> index_array            = {{ 0, 2 }};
    const bool increasing[n]                    = { false, false };
    boost::array<std::size_t,n> shape_array     = {{ 1, 3 }};
    boost::array<int, n>::iterator index        = index_array.begin();
    boost::array<std::size_t,n>::iterator shape = shape_array.begin();

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), false);
}

BOOST_AUTO_TEST_CASE( decrement_2d_degenerate_all )
{
    const int  n             = 2;
    int        index[n]      = { 0, 0 };
    const int  increasing[n] = { 0, 0 };
    const long shape[n]      = { 1, 1 };

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), false);
}

BOOST_AUTO_TEST_CASE( decrement_2d_normal )
{
    const int    n             = 2;
    unsigned int index[n]      = { 1, 2 };
    unsigned int increasing[n] = { 0, 0 };
    unsigned int shape[n]      = { 2, 3 };

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 2);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), false);
}

BOOST_AUTO_TEST_CASE( decrement_2d_normal_usualorder )
{
    const int    n             = 2;
    unsigned int index[n]      = { 1, 2 };
    unsigned int increasing[n] = { 0, 0 };
    unsigned int shape[n]      = { 2, 3 };
    unsigned int order[n]      = { 0, 1 };

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 2);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), false);
}

BOOST_AUTO_TEST_CASE( decrement_2d_normal_reverseorder )
{
    const int          n             = 2;
    unsigned int       index[n]      = { 1, 2 };
    const unsigned int increasing[n] = { 0, 0 };
    const unsigned int shape[n]      = { 2, 3 };
    const unsigned int order[n]      = { 1, 0 };

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 2);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), false);
}

BOOST_AUTO_TEST_CASE( decrement_3d_degenerate_all )
{
    const int         n             = 3;
    signed int        index[n]      = { 0, 0, 0 };
    const signed long increasing[n] = { 0, 0, 0 };
    const signed long shape[n]      = { 1, 1, 1 };

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), false);
}

BOOST_AUTO_TEST_CASE( decrement_3d_degenerate_middle )
{
    const int                   n               = 3;
    long                        index[n]         =  { 2, 0, 2 };
    boost::array<std::size_t,n> increasing_array = {{ 0, 0, 0 }};
    boost::array<std::size_t,n> shape_array      = {{ 3, 1, 3 }};
    boost::array<std::size_t,n>::const_iterator increasing = increasing_array.begin();
    boost::array<std::size_t,n>::const_iterator shape = shape_array.begin();

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 2);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 2);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 2);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 2);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), false);
}

BOOST_AUTO_TEST_CASE( decrement_3d_normal )
{
    const int n = 3;
    std::vector<short> index_array(n, 1);
    std::vector<short> increasing_array(n, 0);
    std::vector<int> shape_array(n, 2);
    std::vector<short>::iterator index = index_array.begin();
    std::vector<short>::const_iterator increasing = increasing_array.begin();
    std::vector<int>::const_iterator shape = shape_array.begin();

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 1);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape), false);
}

BOOST_AUTO_TEST_CASE( decrement_3d_normal_outoforder )
{
    const int n = 3;
    boost::array<short,3> index_array = {{ 1, 0, 2 }};
    boost::array<bool,3> increasing_array = {{ false, false, false }};
    boost::array<int,3> shape_array = {{ 2, 1, 3 }};
    boost::array<long,3> order_array = {{ 2, 0, 1 }};

    boost::array<short,3>::iterator index = index_array.begin();
    boost::array<bool,3>::iterator increasing = increasing_array.begin();
    boost::array<int,3>::iterator shape = shape_array.begin();
    boost::array<long,3>::iterator order = order_array.begin();

    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 1);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 2);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 1);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
    BOOST_CHECK_EQUAL(index[0], 0);
    BOOST_CHECK_EQUAL(index[1], 0);
    BOOST_CHECK_EQUAL(index[2], 0);
    BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), false);
}

BOOST_AUTO_TEST_CASE_TEMPLATE( crement_3d_spot_check_behavior_1, ASCENDING, int_zero_one_type )
{
    const int n = 3;
    typedef boost::array<int,n> array_type;

    // Like shape = { 4, 3, 2 } with the second index frozen at zero
    const array_type           shape_array = {{ 4, 1, 2 }};
    array_type::const_iterator shape       = shape_array.begin();

    const array_type order_fast_dontcare_slow[] = {
        { 0, 1, 2 },
        { 1, 0, 2 },
        { 0, 2, 1 }
    };
    const std::size_t n_order
        = sizeof(order_fast_dontcare_slow)/sizeof(order_fast_dontcare_slow[0]);
    const array_type order_slow_dontcare_fast[n_order] = {
        { 1, 2, 0 },
        { 2, 1, 0 },
        { 2, 0, 1 }
    };

    for (std::size_t i = 0; i < n_order; ++i) {
        array_type       index_array      = {{ 0, 0, 1 }};
        const array_type increasing_array = {{ 1, ASCENDING::type::value, 0 }};

        array_type::iterator       index      = index_array.begin();
        array_type::const_iterator increasing = increasing_array.begin();

        BOOST_TEST_MESSAGE("Testing increasing " << increasing_array
                           << " with ordering " << order_fast_dontcare_slow[i]
                           << " from initial "  << index_array );
        array_type::const_iterator order = order_fast_dontcare_slow[i].begin();

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(1)(0)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(2)(0)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(3)(0)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(0)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(1)(0)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(2)(0)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(3)(0)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), false);
    }

    for (std::size_t i = 0; i < n_order; ++i) {
        array_type       index_array      = {{ 0, 0, 1 }};
        const array_type increasing_array = {{ 1, ASCENDING::type::value, 0 }};

        array_type::iterator       index      = index_array.begin();
        array_type::const_iterator increasing = increasing_array.begin();

        BOOST_TEST_MESSAGE("Testing increasing " << increasing_array
                           << " with ordering " << order_slow_dontcare_fast[i]
                           << " from initial "  << index_array );
        array_type::const_iterator order = order_slow_dontcare_fast[i].begin();

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(0)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(1)(0)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(1)(0)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(2)(0)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(2)(0)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(3)(0)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(3)(0)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), false);
    }

    for (std::size_t i = 0; i < n_order; ++i) {
        array_type       index_array      = {{ 3, 0, 0 }};
        const array_type increasing_array = {{ 0, ASCENDING::type::value, 1 }};

        array_type::iterator       index      = index_array.begin();
        array_type::const_iterator increasing = increasing_array.begin();

        BOOST_TEST_MESSAGE("Testing increasing " << increasing_array
                           << " with ordering " << order_fast_dontcare_slow[i]
                           << " from initial "  << index_array );
        array_type::const_iterator order = order_fast_dontcare_slow[i].begin();

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(2)(0)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(1)(0)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(0)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(3)(0)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(2)(0)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(1)(0)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(0)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), false);
    }

    for (std::size_t i = 0; i < n_order; ++i) {
        array_type       index_array      = {{ 3, 0, 0 }};
        const array_type increasing_array = {{ 0, ASCENDING::type::value, 1 }};

        array_type::iterator       index      = index_array.begin();
        array_type::const_iterator increasing = increasing_array.begin();

        BOOST_TEST_MESSAGE("Testing increasing " << increasing_array
                           << " with ordering " << order_slow_dontcare_fast[i]
                           << " from initial "  << index_array );
        array_type::const_iterator order = order_slow_dontcare_fast[i].begin();

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(3)(0)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(2)(0)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(2)(0)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(1)(0)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(1)(0)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(0)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(0)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), false);
    }
}

BOOST_AUTO_TEST_CASE_TEMPLATE( crement_3d_spot_check_behavior_2, ASCENDING, int_zero_one_type )
{
    const int n = 3;
    typedef boost::array<int,n> array_type;

    // Like shape = { 4, 3, 2 } with the first index frozen at zero
    const array_type           shape_array = {{ 1, 3, 2 }};
    array_type::const_iterator shape       = shape_array.begin();

    const array_type order_dontcare_fast_slow[] = {
        { 0, 1, 2 },
        { 1, 0, 2 },
        { 1, 2, 0 }
    };
    const std::size_t n_order
        = sizeof(order_dontcare_fast_slow)/sizeof(order_dontcare_fast_slow[0]);
    const array_type order_dontcare_slow_fast[n_order] = {
        { 0, 2, 1 },
        { 2, 0, 1 },
        { 2, 1, 0 }
    };

    for (std::size_t i = 0; i < n_order; ++i) {
        array_type       index_array      = {{ 0, 0, 1 }};
        const array_type increasing_array = {{ ASCENDING::type::value, 1, 0 }};

        array_type::iterator       index      = index_array.begin();
        array_type::const_iterator increasing = increasing_array.begin();

        BOOST_TEST_MESSAGE("Testing increasing " << increasing_array
                           << " with ordering " << order_dontcare_fast_slow[i]
                           << " from initial "  << index_array );
        array_type::const_iterator order = order_dontcare_fast_slow[i].begin();

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(1)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(2)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(0)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(1)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(2)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), false);
    }

    for (std::size_t i = 0; i < n_order; ++i) {
        array_type       index_array      = {{ 0, 0, 1 }};
        const array_type increasing_array = {{ ASCENDING::type::value, 1, 0 }};

        array_type::iterator       index      = index_array.begin();
        array_type::const_iterator increasing = increasing_array.begin();

        BOOST_TEST_MESSAGE("Testing increasing " << increasing_array
                           << " with ordering " << order_dontcare_slow_fast[i]
                           << " from initial "  << index_array );
        array_type::const_iterator order = order_dontcare_slow_fast[i].begin();

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(0)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(1)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(1)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(2)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(2)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), false);
    }

    for (std::size_t i = 0; i < n_order; ++i) {
        array_type       index_array      = {{ 0, 2, 0 }};
        const array_type increasing_array = {{ ASCENDING::type::value, 0, 1 }};

        array_type::iterator       index      = index_array.begin();
        array_type::const_iterator increasing = increasing_array.begin();

        BOOST_TEST_MESSAGE("Testing increasing " << increasing_array
                           << " with ordering " << order_dontcare_fast_slow[i]
                           << " from initial "  << index_array );
        array_type::const_iterator order = order_dontcare_fast_slow[i].begin();

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(1)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(0)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(2)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(1)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(0)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), false);
    }

    for (std::size_t i = 0; i < n_order; ++i) {
        array_type       index_array      = {{ 0, 2, 0 }};
        const array_type increasing_array = {{ ASCENDING::type::value, 0, 1 }};

        array_type::iterator       index      = index_array.begin();
        array_type::const_iterator increasing = increasing_array.begin();

        BOOST_TEST_MESSAGE("Testing increasing " << increasing_array
                           << " with ordering " << order_dontcare_slow_fast[i]
                           << " from initial "  << index_array );
        array_type::const_iterator order = order_dontcare_slow_fast[i].begin();

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(2)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(1)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(1)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(0)(0));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), true);
        BOOST_CHECK_EQUAL(index_array, boost::assign::list_of(0)(0)(1));

        BOOST_REQUIRE_EQUAL(crement<n>(index,increasing,shape,order), false);
    }
}

BOOST_AUTO_TEST_SUITE_END()

BOOST_AUTO_TEST_SUITE( indexed_element_magnitude_comparator )

using pencilfft::detail::indexed_element_magnitude_comparator;
using pencilfft::detail::make_indexed_element_magnitude_comparator;

BOOST_AUTO_TEST_CASE( indexed_element_magnitude_comparator_operator_positive )
{
    const double data[3] = { 0.0, 1.0, 2.0 };
    indexed_element_magnitude_comparator<const double *> c(&data[0]);

    BOOST_CHECK_EQUAL(true, c(0, 1));
    BOOST_CHECK_EQUAL(true, c(1, 2));
    BOOST_CHECK_EQUAL(true, c(0, 2));

    BOOST_CHECK_EQUAL(false, c(1, 0));
    BOOST_CHECK_EQUAL(false, c(2, 1));
    BOOST_CHECK_EQUAL(false, c(2, 0));
}

BOOST_AUTO_TEST_CASE( indexed_element_magnitude_comparator_operator_mixed )
{
    const double data[3] = { 0.0, -1.0, -2.0 };
    indexed_element_magnitude_comparator<const double *> c(&data[0]);

    BOOST_CHECK_EQUAL(true, c(0, 1));
    BOOST_CHECK_EQUAL(true, c(1, 2));
    BOOST_CHECK_EQUAL(true, c(0, 2));

    BOOST_CHECK_EQUAL(false, c(1, 0));
    BOOST_CHECK_EQUAL(false, c(2, 1));
    BOOST_CHECK_EQUAL(false, c(2, 0));
}

BOOST_AUTO_TEST_CASE( indexed_element_magnitude_comparator_stable_sort )
{
    const int n = 5;
    const double data[n]    = { 0, 1, 2, 3, 4 };
    std::size_t  indices[n] = { 3, 1, 4, 0, 2 };

    std::stable_sort(indices, indices + n,
            make_indexed_element_magnitude_comparator(&data[0]));
    BOOST_CHECK_EQUAL(0, indices[0]);
    BOOST_CHECK_EQUAL(1, indices[1]);
    BOOST_CHECK_EQUAL(2, indices[2]);
    BOOST_CHECK_EQUAL(3, indices[3]);
    BOOST_CHECK_EQUAL(4, indices[4]);
}

BOOST_AUTO_TEST_SUITE_END()
